USE Practices;
CREATE TABLE EMPLOYEES (
EMP_ID VARCHAR(100) PRIMARY KEY NOT NULL,
EMP_NAME VARCHAR(100) NOT NULL,
DATE_OF_JOIN DATE NOT NULL,
DEPARTMENT VARCHAR(100) NOT NULL,
DEPT_ID VARCHAR(100) NOT NULL,
SALARY INT NOT NULL,
FOREIGN KEY (DEPT_ID) REFERENCES DEPARTMENTS(DEPT_ID)
);
DROP TABLE EMPLOYEES;

INSERT INTO EMPLOYEES VALUES 
('EM001','Gowtham','2024-11-13','Developer','D001',50000),
('EM002','Gopinath','2024-11-13','Developer','D001',50000),
('EM003','Badhri','2024-11-13','Fullstack Developer','D002',40000),
('EM004','Jayashree','2024-11-15','Tester','D003',45000),
('EM005','Jothika','2024-11-14','Tester','D003',45000),
('EM006','Lakshmikanth','2024-11-14','Designer','D004',60000),
('EM007','Arun Kumar','2024-11-15','Fullstack Developer','D002',40000),
('EM008','Balaji','2024-11-16','Developer','D001',50000),
('EM009','Krish','2024-11-14','Designer','D004',55000),
('EM010','Sandy','2024-11-16','Fullstack Developer','D002',50000);

CREATE TABLE DEPARTMENTS(
DEPT_ID VARCHAR(100) PRIMARY KEY UNIQUE NOT NULL,
DEPARTMENT VARCHAR(100) UNIQUE NOT NULL,
DEPT_MANAGER VARCHAR(100) NOT NULL,
SALARY INT NOT NULL
);
INSERT INTO DEPARTMENTS VALUES 
('D001','Developer','Kelly',90000),
('D002','Fullstack Developer','Josh',70000),
('D003','Tester','Kepella',65000),
('D004','Designer','Dimitri',85000);

CREATE TABLE PROJECTS(
PROJECT_ID VARCHAR(100) PRIMARY KEY NOT NULL,
PROJECT_NAME VARCHAR(100) UNIQUE NOT NULL,
EMP_ID VARCHAR(100) NOT NULL,
FOREIGN KEY (EMP_ID) REFERENCES EMPLOYEES(EMP_ID)
);
INSERT INTO PROJECTS (PROJECT_ID, PROJECT_NAME, EMP_ID)
VALUES
('PR001', 'Project A', 'EM001'),
('PR002', 'Project B', 'EM001'),
('PR003', 'Project C', 'EM002'),
('PR004', 'Project D', 'EM003'),
('PR005', 'Project E', 'EM003'),
('PR006', 'Project F', 'EM004'),
('PR007', 'Project G', 'EM005'),
('PR008', 'Project H', 'EM001'),
('PR009', 'Project I', 'EM002'),
('PR010', 'Project J', 'EM003');



ALTER TABLE EMPLOYEES ADD MANAGER VARCHAR(100);


UPDATE EMPLOYEES 
SET MANAGER = 'Kelly' WHERE EMP_ID = 'EM001';

UPDATE EMPLOYEES 
SET MANAGER = 'Josh' WHERE EMP_ID = 'EM002';

UPDATE EMPLOYEES 
SET MANAGER = 'Kepella' WHERE EMP_ID = 'EM004';

UPDATE EMPLOYEES 
SET MANAGER = 'Dimitri' WHERE EMP_ID = 'EM006';

UPDATE EMPLOYEES 
SET MANAGER = 'Dimitri' WHERE EMP_ID = 'EM007';

UPDATE EMPLOYEES 
SET MANAGER = 'Dimitri' WHERE EMP_ID = 'EM003';

UPDATE EMPLOYEES 
SET MANAGER = 'Kelly' WHERE EMP_ID = 'EM010';

-- Query 1
SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;
SELECT * FROM PROJECTS;

-- Query 2
SELECT EMP_NAME, SALARY FROM EMPLOYEES;

-- Write a query to find all employees whose salary is greater than 50,000
SELECT EMP_NAME, SALARY FROM EMPLOYEES WHERE SALARY > 50000;

-- List all employees who joined the company in the year 2020.
SELECT EMP_NAME, DATE_OF_JOIN FROM EMPLOYEES WHERE YEAR(DATE_OF_JOIN) = 2020;

-- Retrieve the details of employees whose names start with the letter 'A'
SELECT EMP_NAME FROM EMPLOYEES WHERE EMP_NAME LIKE 'A%';

-- Aggregate Functions

-- Write a query to calculate the average salary of all employees.
SELECT AVG(SALARY) FROM EMPLOYEES;

-- Find the total number of employees in the company.
SELECT COUNT(*) AS COUNT_OF_EMPLOYEES FROM EMPLOYEES;

-- Write a query to find the highest salary in the employees table.
SELECT MAX(SALARY) AS MAX_SALARY FROM EMPLOYEES;

-- Calculate the total salary paid by the company for all employees.
SELECT SUM(SALARY) AS TOTAL_SALARY FROM EMPLOYEES; 

-- Find the count of employees in each department.
SELECT DEPARTMENT, COUNT(*) AS COUNT_OF_EMPLOYEES FROM EMPLOYEES GROUP BY DEPARTMENT;

-- Joins

-- Write a query to retrieve employee names along with their department names (using employees and departments tables).
SELECT EMPLOYEES.EMP_NAME, DEPARTMENTS.DEPARTMENT FROM DEPARTMENTS 
RIGHT JOIN EMPLOYEES ON DEPARTMENTS.DEPT_ID = EMPLOYEES.DEPT_ID;

-- List all employees who have a manager (self-join on employees table).
SELECT E1.EMP_NAME, E2.MANAGER FROM EMPLOYEES E1 
JOIN EMPLOYEES E2 ON E1.EMP_ID = E2.EMP_ID WHERE E2.MANAGER IS NOT NULL;


-- Find the names of employees who are working on multiple projects (using employees and projects tables)
SELECT EMPLOYEES.EMP_NAME, COUNT(PROJECTS.PROJECT_ID) AS NO_OF_PROJECTS FROM PROJECTS
RIGHT JOIN EMPLOYEES ON PROJECTS.EMP_ID = EMPLOYEES.EMP_ID
GROUP BY EMPLOYEES.EMP_NAME HAVING COUNT(PROJECTS.PROJECT_ID)>1
ORDER BY EMPLOYEES.EMP_NAME;

-- Write a query to display all projects and the employees assigned to them.
SELECT PROJECTS.PROJECT_NAME, EMPLOYEES.EMP_NAME FROM PROJECTS
LEFT JOIN EMPLOYEES ON EMPLOYEES.EMP_ID = PROJECTS.EMP_ID;

-- Retrieve the names of employees who do not belong to any department
SELECT EMP_NAME FROM EMPLOYEES
WHERE DEPARTMENT IS NULL;

-- Subqueries

-- Write a query to find the employees with the second-highest salary.
SELECT EMP_NAME, SALARY FROM EMPLOYEES
WHERE SALARY = (SELECT SALARY FROM EMPLOYEES ORDER BY SALARY DESC LIMIT 1 OFFSET 1);

-- Retrieve the names of employees whose salary is above the department average salary.
SELECT E.EMP_NAME, E.SALARY, E.DEPARTMENT FROM EMPLOYEES E
WHERE E.SALARY > (SELECT AVG(E1.SALARY) FROM EMPLOYEES E1 WHERE E1.DEPARTMENT = E.DEPARTMENT);

-- Write a query to find the department with the highest number of employees.
-- SELECT DEPARTMENT, COUNT(EMP_ID) AS COUNT_OF_EMPLOYEES FROM EMPLOYEES GROUP BY DEPARTMENT
-- HAVING COUNT(*) = (SELECT MAX(COUNT(EMP_ID)) FROM EMPLOYEES);

-- List all employees who work in a department located in 'New York'.
ALTER TABLE DEPARTMENTS ADD DEPT_LOCATION VARCHAR(100);

UPDATE DEPARTMENTS
SET DEPT_LOCATION = 'New York'
WHERE DEPT_ID = 'D001';

UPDATE DEPARTMENTS
SET DEPT_LOCATION = 'New Jersey'
WHERE DEPT_ID = 'D002';

UPDATE DEPARTMENTS
SET DEPT_LOCATION = 'Singapore'
WHERE DEPT_ID = 'D003';

UPDATE DEPARTMENTS
SET DEPT_LOCATION = 'Japan'
WHERE DEPT_ID = 'D004';

SELECT * FROM DEPARTMENTS;

SELECT EMPLOYEES.EMP_NAME, DEPARTMENTS.DEPT_LOCATION FROM DEPARTMENTS
RIGHT JOIN EMPLOYEES ON EMPLOYEES.DEPT_ID = DEPARTMENTS.DEPT_ID 
WHERE DEPARTMENTS.DEPT_LOCATION = 
(SELECT DEPARTMENTS.DEPT_LOCATION FROM DEPARTMENTS WHERE DEPARTMENTS.DEPT_LOCATION = 'New York');

INSERT INTO DEPARTMENTS VALUES 
('D005','HR','Maddy',75000,'China'),
('D006','Finance','Azar',80000,'Germany');

INSERT INTO EMPLOYEES VALUES
('EM011','Andrea','2020-12-01','HR','D005',53000,'Maddy'),
('EM012','Andy','2019-11-10','Finance','D006',48000,'Azar');

-- Write a query to find employees who work in either the 'HR' or 'Finance' department.
SELECT EMPLOYEES.EMP_NAME, DEPARTMENTS.DEPARTMENT FROM EMPLOYEES
RIGHT JOIN DEPARTMENTS ON EMPLOYEES.DEPT_ID = DEPARTMENTS.DEPT_ID
WHERE DEPARTMENTS.DEPARTMENT = 'HR' OR DEPARTMENTS.DEPARTMENT = 'Finance';

-- Retrieve the names of employees who are working on both Project A and Project B.
SELECT EMPLOYEES.EMP_NAME, PROJECTS.PROJECT_NAME FROM PROJECTS
RIGHT JOIN EMPLOYEES ON EMPLOYEES.EMP_ID = PROJECTS.EMP_ID
WHERE PROJECTS.PROJECT_NAME IN ('Project A','Project B');

-- Find employees who are not assigned to any project.
SELECT EMPLOYEES.EMP_ID, EMPLOYEES.EMP_NAME, PROJECTS.PROJECT_NAME FROM PROJECTS
RIGHT JOIN EMPLOYEES ON EMPLOYEES.EMP_ID = PROJECTS.EMP_ID
WHERE EMPLOYEES.EMP_ID NOT IN (SELECT PROJECTS.EMP_ID FROM PROJECTS);

-- Write a query to get all unique job titles across all departments.
SELECT DISTINCT DEPARTMENT AS JOB_TITLE FROM EMPLOYEES;

-- Combine two tables (employees and former_employees) and remove duplicates.
CREATE TABLE FORMER_EMPLOYEES (
EMP_ID VARCHAR(100) PRIMARY KEY  NOT NULL,
EMP_NAME VARCHAR(100),
DEPT_ID VARCHAR(100),
DEPARTMENT VARCHAR(100)
);
INSERT INTO FORMER_EMPLOYEES (EMP_ID, EMP_NAME, DEPT_ID, DEPARTMENT)
VALUES 
('EM013', 'Kumar', 'D003', 'Tester'),
('EM004', 'Jayashree', 'D003', 'Tester'),
('EM005', 'Jothika', 'D003', 'Tester'),
('EM007', 'Arun Kumar', 'D002', 'Fullstack Developer'),
('EM014', 'Mala', 'D004', 'Designer'),
('EM015', 'Suresh', 'D001', 'Developer'),
('EM016', 'Ramesh', 'D003', 'Tester'),
('EM017', 'Priya', 'D002', 'Fullstack Developer');

DROP TABLE FORMER_EMPLOYEES;
SELECT * FROM EMPLOYEES;

SELECT EMP_ID,EMP_NAME,DEPT_ID,DEPARTMENT
FROM EMPLOYEES
UNION
SELECT *
FROM FORMER_EMPLOYEES ORDER BY EMP_ID;

-- DML and DDL
-- Write a query to add a new employee to the employees table.

INSERT INTO EMPLOYEES VALUES 
('EM018','Raghul','2019-04-26','HR','D005',52000,'Maddy'),
('EM019','Raja','2020-04-23','Finance','D006',47000,'Azar');

SET
SQL_SAFE_UPDATES =0;

-- Update the salary of all employees in the 'IT' department by 10%.
UPDATE EMPLOYEES 
SET SALARY = SALARY*1.10
WHERE DEPARTMENT = 'HR';

SELECT * FROM EMPLOYEES;
-- Delete all employees who have not worked for more than 5 years.
DELETE FROM EMPLOYEES
WHERE DATEDIFF(CURDATE(), DATE_OF_JOINING) < (5 * 365);

-- Create a new table departments_backup with the same structure as the departments table
CREATE TABLE departments_backup AS
SELECT * FROM departments;

SELECT * FROM DEPARTMENTS_BACKUP;

-- Drop the temporary_data table from the database.
DROP TABLE FORMER_EMPLOYEES;

-- CONSTRAINTS
-- Add a primary key to the employees table.
ALTER TABLE FROMER_EMPLOYEES
ADD PRIMARY KEY (EMP_ID);

-- Write a query to create a foreign key between employees and departments tables.
describe PROJECTS;
ALTER TABLE PROJECTS
ADD CONSTRAINT FK_FORMER_EMPLOYEE
FOREIGN KEY (EMP_ID) REFERENCES FORMER_EMPLOYEES(EMP_ID);

-- Add a unique constraint to the email column in the employees table.
ALTER TABLE FORMER_EMPLOYEES
ADD CONSTRAINT UNIQUE_KEY
UNIQUE (EMP_ID);

-- Remove the NOT NULL constraint from the phone_number column in the employees table.
ALTER TABLE FORMER_EMPLOYEES
MODIFY COLUMN EMP_NAME VARCHAR(100) NOT NULL;



-- Basic PL/SQL Programs

-- 1. Write a PL/SQL block to calculate the factorial of a given number.
DELIMITER $$
CREATE PROCEDURE FACTORIAL_PRG(IN FACT_NUM INT)
DETERMINISTIC
BEGIN
DECLARE 
FACT INT DEFAULT 1;
DECLARE 
i INT;
SET i = FACT_NUM;
WHILE i>0 DO
SET FACT = i*FACT;
SET i = i-1;
END WHILE;
SELECT FACT AS RESULT;
END $$
DELIMITER ;
DROP PROCEDURE FACTORIAL_PRG;
CALL FACTORIAL_PRG(5);


-- 2. Write a PL/SQL block to display the Fibonacci series up to n terms.
DELIMITER $$
CREATE PROCEDURE FIBONACCI(IN FIRST_NUM INT,IN SECOND_NUM INT)
DETERMINISTIC
BEGIN
DECLARE NO_OF_TRY INT DEFAULT 5;
DECLARE FIRST_NUMBER INT;
DECLARE SECOND_NUMBER INT;
DECLARE TEMP INT DEFAULT 0;
DECLARE i INT DEFAULT 0;

SET FIRST_NUMBER = FIRST_NUM;
SET SECOND_NUMBER = SECOND_NUM;

WHILE i<NO_OF_TRY DO
SET TEMP =FIRST_NUMBER + SECOND_NUMBER;
SET FIRST_NUMBER = SECOND_NUMBER;
SET SECOND_NUMBER = TEMP;
SELECT TEMP AS RESULT;
SET i = i+1;
END WHILE;
END$$
DELIMITER ;
DROP PROCEDURE FIBONACCI;
CALL FIBONACCI(1,2);




-- 3. Create a PL/SQL block to reverse a given string.
DELIMITER $$
CREATE PROCEDURE REVERSE_STRING(IN INPUT_STRING VARCHAR(100))
BEGIN
DECLARE RESULT_STRING VARCHAR(100) DEFAULT ' ';
DECLARE i INT;
SET  i = length(INPUT_STRING);
WHILE i>0 DO
SET RESULT_STRING = CONCAT(RESULT_STRING, SUBSTRING(INPUT_STRING, i, 1));
SET i = i - 1;
END WHILE;
SELECT RESULT_STRING AS REVERSED_STRING;
END $$
DELIMITER ;
DROP PROCEDURE REVERSE_STRING;
CALL REVERSE_STRING('MADDY');


-- 5. Write a program to calculate the sum of all digits of a given number.
DELIMITER $$
CREATE PROCEDURE SUM_OF_DIGITS_IN_NUMBER(IN INPUT_NUMBER INT)
DETERMINISTIC
BEGIN
DECLARE GIVEN_NUMBER INT;
DECLARE REM_NUMBER INT DEFAULT 0;
DECLARE SUM_OF_DIGITS INT DEFAULT 0;
SET GIVEN_NUMBER = INPUT_NUMBER;
WHILE INPUT_NUMBER >= 1 DO
SET REM_NUMBER = INPUT_NUMBER mod 10;
SET SUM_OF_DIGITS = SUM_OF_DIGITS + REM_NUMBER;
SET INPUT_NUMBER = FLOOR(INPUT_NUMBER / 10);
END WHILE;
SELECT CONCAT('The given number is:',GIVEN_NUMBER,'/The sum of digits is: ',SUM_OF_DIGITS) AS ADDITION_OF_DIGITS;
END $$
DELIMITER ;
DROP PROCEDURE  SUM_OF_DIGITS_IN_NUMBER;
CALL SUM_OF_DIGITS_IN_NUMBER(723);




